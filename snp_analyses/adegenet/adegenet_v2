# first pass at adegenet tutorial
# for analyzing snps under selection (PCAdapt)
# updated aug 2019

# load the packages
library(adegenet)
library("devtools")
#source("https://bioconductor.org/biocLite.R")
#biocLite("qvalue")
#install_github("whitlock/OutFLANK")
library("pcadapt")
library("qvalue")
library("OutFLANK")
library("ggplot2")
library("dplyr")
library(cowplot)
library("poppr")
library("dendextend")
library("ape")
library(vcfR)
#library("corrplot") # this is for the correlation matrix
#source("http://www.sthda.com/upload/rquery_cormat.r")
library(reshape2)

# set the working directory
setwd("~/Desktop/PhD/Symbiodinium fitti/SNP_under_selection/v_contam_rm_08082019/")

# import the vcf
vcf <- read.vcfR("~/Desktop/PhD/Symbiodinium fitti/contam_rm_080819/hq_nocontam_rename_aug19.vcf")

# add in poptab
# eventually add in coordinates, depth, etc
poptab <- read.table("~/Desktop/PhD/Symbiodinium fitti/contam_rm_080819/poptab.txt", header = T)

# convert vcf
gind <- vcfR2genlight(vcf, n.cores = 3)
gind@pop <- as.factor(poptab$host)
#gind@other <- as.factor(poptab$host)

# attempt making a pca with the glPCA function
# this saved my ass: http://adegenet.r-forge.r-project.org/files/tutorial-genomics.pdf
pca <- glPca(gind, n.cores = 4)
pca
scatter(pca, npcs=2, col = gind@pop)

#pca
s.class(pca$scores, fac=pop(gind),col=transp(funky(15),.6),
axesel=FALSE, cstar=0, cpoint=3)

col <- funky(15)

# other thing
myCol <- colorplot(pca$scores,pca$scores, fac=pop(gind), transp=TRUE, cex=4,
axesel=FALSE, cstar=0, cpoint=3)
abline(h=0,v=0, col="grey")
add.scatter.eig(pca$eig[1:40],2,1,2, posi="topleft", inset=.05, ratio=.3)

#loading plot
loadingplot(pca)

# DAPC
dapc <- dapc(gind, glPca = pca)
scatter(dapc) # makes a biplot
compoplot(dapc) # shows probability of membership
loadingplot(dapc$pca.loadings)
loadingplot(dapc$var.contr)

# create genclone object
genclone <- as.snpclone(gind)
#as.genind(gind)

#calculate the bitwise distance between individuals
xdis1 <- bitwise.dist(genclone, missing_match=FALSE)
# xdis2 <- bitwise.dist(gind, missing_match=FALSE) # these are the same

###### visualize the  matrix
# resources: http://www.sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization; https://rpubs.com/lgadar/matrix-visualizations 

# prep the data
xdis <- as.matrix(xdis1)

# Get lower triangle of the correlation matrix
  get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
  }
  
# Use correlation between variables as distance
  reorder_cormat <- function(cormat){
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
  }
  
  
  #xdis <- reorder_cormat(xdis)
#lower_tri <- get_lower_tri(xdis)
mlt <- melt(xdis, na.rm = TRUE) # makes var1 & var2 to plot but only lower tri.

fig <- ggplot(data= mlt, aes(x=Var1, y=Var2, fill=value))+
  geom_tile() +
 scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint=0.3852, limit = c(0,0.8), space = "Lab", 
   name="Distance") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 4, hjust = 1), axis.text.y = element_text(size=4))+
  theme(axis.title = element_blank())+
 coord_fixed()
fig
save_plot("bitwise_dist.png", fig, base_aspect_ratio = 1.9)

#rquery.cormat(xdis, graphType = "heatmap")
